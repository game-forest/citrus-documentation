Плавная подгрузка ресурсов в цитрусе.

Цитрус не требует каких-либо специальных действий для подгрузки текстур, звуков и прочих ресурсов. Однако, если во время игры потребуется загрузить какую либо тяжеловесную анимацию, то игра может подвиснуть и испортить игроку удовольствие, а игра потерять в рейтинге.
Нахождение мест подгрузки "тяжелых" ресурсов осложняется тем фактом, что на iOS игра подвисает в тех местах, где на PC все гладко.
Для выявления таких мест есть супер-метод: запуск игры с параметром "--Jerky". Если запустить игру с этим параметром, то цитрус начинает симулировать задержки при подгрузке ресурсов, причем в лог попадает список файлов с указанием времени загрузки (время рассчитывается пропорционально размеру файла).
Хорошо: проблемные ресурсы обнаружены, что дальше?
Дальше есть два способа избавится от задержек:
1) Синхронная загрузка во время черного экрана на старте уровня
2) Асинхронная загрузка если во время игры происходит резкая смена сеттинга (режим мини-игры, упавший с небес бонус и т.д.)

Синхронная загрузка реализуется следующим паттерном:
1) Создаются все тяжелые сцены. Если определенная сцена потребуется для неоднократного создания игровых объектов, можно использовать паттерн "прототип":
Например: Класс Ninja содержит сцену NinjaRoot и статический прототип NinjaProto. NinjaProto подгружается в начале игры, и далее, когда нужно с него делается быстрая копия (Node.DeepCloneFast()) и сохраняется в NinjaRoot.
2) Для сцен делается кеширующая подгрузка графики методом Node.Preload(). Этот метод пробегается по всем детям и подгружает всю требуемую графику.
3) Те текстуры, на которые нет прямых ссылок из сцен, подгружаются методом:
TexturePool.Instance.PreloadAll(pathPrefix)
TexturePool.Instance.Preload(assetPath)

Асинхронная загрузка.
Итак к нам упал с неба бонус, нужно срочно подгрузить 5 мегов текстур и звуков. Как сделать плавно? А все очень просто, нужно использовать те же методы что и выше, только загрузку делать в параллельном потоке (создание сцен и подгрузка графики в Цитрусе потокобезопасно). Вот пример:
		private IEnumerator<object> SpawnNinjaTask()
		{
			yield return BackgroundOperation.Run(PreloadNinja);
			// Теперь можно нашего ниндзю показать в игре
			var ninja = ninjaProto.DeepCloneFast<Widget>();
			...
		}

		static void PreloadNinja()
		{
			if (ninjaProto == null) {
				ninjaProto = new Frame("Game/Bonuses/Ninja");
			}
			ninjaProto.Preload();
		}
Ну, а вызывать SpawnNinjaTask нужно из нашего замечательного CoolWorkflow.

Со сценами и текстурами все ясно, а что насчет звуков?
А со звуками все просто. Цитрусовый звуковой движок теперь ВСЕГДА подгружает звуки асинхронно. Для пользователя задержка перед воспроизведением звука (если он не был еще закэширован) в четверть секунды незаметна, зато игра больше не лагает. Все методы для контроля звука (Volume, Pan, Pitch) работают как и раньше, но перед Pause/Resume нужно проверить что звук действительно был загружен (Sound.Loaded == true).

Что еще есть в цитрусе, связанное с многопоточностью?
	static void Application.InvokeOnMainThread(Action action);
Этот метод выполняет действие в главном потоке, между апдейтом и рендерингом кадра.
Если мы сейчас в главном потоке, действие выполняется немедленно. Этот метод особенно полезен на iOS, т.к. многие iOS-апишные колбэки вызываются не из главного потока.

Что почитать? Погуглите про:
	System.ComponentModel.BackgroundWorker -- класс-обертка для выполнения операций в параллельном потоке;
	System.Collections.Concurrent -- набор thread-safe коллекций, которые появились в .NET 4.0.
