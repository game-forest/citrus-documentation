# Валидация

Валидация позволяет контроллировать корректность данных в ассетах. В Цитрусе есть несколько типов валидации.

1. Валидация по свойству
2. Валидация по типу
3. Валидация по расширению ассета

В любом из этих случев вам надо реализовать интерфейс `Lime.Validation.IValidator<T>` где T это входной тип данных для валидации. В нём надо реализовать единственный метод 

```csharp
IEnumerable<(Lime.Validation.Result Result, string Message)> Validate(T value);
```
При вызове этого метода будет использована не генерик версия данного интерфейса `Lime.Validation.IValidator`, это означает что где-то там есть каст `value` из `object` в `T`. Если не верно указан тип для валидатора, то этот каст бросит исключение.

Result может быть `Info`, `Error` и `Warning`. В Message должен содержаться текст соответствующий результату. Этот метод должен перечислять пары результат и сообщение согласно логике валидатора. Примеры валидаторов можно посмотреть в Lime.Validation. 

Все валидаторы не должны иметь состояния, т.к. не гарантируется, будут ли они пересозданы или закешированы в той или иной ситуации.

Далее реализация этого интерфейса либо регистрируется в `Orange.ValidationRunner` либо является атрибутом.

## Валидация свойства

Валидаторы свойств извлекаются из атрибутов свойства с помощью рефлексии. То есть чтобы повесить валидатор на свойство надо унаследоваться от `System.Attribute` и реализовать `IValidator<T>`, а затем применить его к свойству.

Такие валидаторы можно параметризировать и в каждом конкретном случае передавать параметры применимые к конкретному свойству. Например см. `Lime.Validation.Range`.

Только для валидаторов свойств проводится проверка на реализацию интерфейса `Lime.Validation.IRequireOwner`, если она есть, то перед вызовом валидации валидатору будет назначен владелец. При этом проверяемое значение для свойства не обязательно должно быть уже присвоено, т.к. оно передаётся в `Validate` отдельно.

Только для валидаторов свойств проводится проверка не реализацию интерфейса `Lime.Validation.PassThroughEnumerable`, если она есть, то такие валидаторы будучи назначенными на свойства будут применяться не к самому свойству, а к его элементам, если свойство реализует `IEnumerable`. Это верно также для вложенных перечислений, например `public List<List<List<int>>> List { get; set; }`.

Валидаторы свойств вызываются для всех свойств маркированных `YuzuMember` через `Orange.ValidationRunner.ValidateObject` (который можно использовать в своих валидаторах ассетов, а также используется для валидации сцен), а также для `YuzuMember` и `TangerineInspect` маркированных полей валидаторы свойств будут вызваны в инспекторе в Танжерине. (И в некоторых других интерфейсах редактирования свойств в танжерине).

## Валидация типа

Аналогично валидации свойства, но атрибут применяется к объявлению типа.

Вызывается через　`Orange.ValidationRunner.ValidateObject` для всех значений.

Вызывается для всех значений свойств в Танжерине в инспекторе. Для поиска атрибутов валидации также перечисляются интерфейсы, которые реализует рантайм тип данного значения свойства.


## Валидация ассета

Такой валидатор должен валидировать значение типа `string`. Это путь к ассету в текущем бандле (входной бандл для кука, asset directory). Если данный ассет можно десериализовать в инстанс некого класса, то для из него можно вызвать `Orange.ValidationRunner.ValidateObject` и перечислить его результаты. 

При куке ассетов для каждого нового или изменённого файла в директории ассетов проекта, если данный файл попадает в один из cooking stages, вызываются все валидаторы зарегистрированные через Orange.ValidationRunner.RegisterAssetValidator.

Также через Orange Action -> Validate Everything валидаторы ассетов будут вызваны для каждого ассета в директории ассетов.

## Примеры того, что можно валидировать.

- Допустимые интервалы для численных значений.
- Символы в путях и айди. Если у вас в проекте естьк акие-то соглашения по именованию, можно проверять эти соглашения.
- Для изображений можно проверять что они не сильно большие, если попробовать частично выяснить кладётся ли оно в атлас или нет, то в случае если нет, можно проверять, насколько оно не вписывается в степень двойки.
- Про размер изображений -- проверять размер на диске, то есть если по факту файл занимает в несколько раз больше чем разжатое изображение, возможно там какая-то метадата лишняя.
- Можно проверять, что цветовой профиль отсутсвует или указан СРГБ, который должен у нас использоваться согласно документации. Ну и что угодно в кастомных компонентах и виджетах.
- Информировать, что размер или аспект ратио виджета отличается от оного у изображения, которое этот виджет рисует.
- Убеждаться, что для текстуры виджета установленны параметры, которые требуются данному виджету. (Например WrapModeU/V == Clamp/Mirror)
- Проверять композицию нод и компонент. Это означает, что среди детей ноды должны быть только дети допустимых типов для каждого типа нода владельца. Аналогично для компонент.
- Проверять, что указанный ассет существует.
- Проверять, что бандл сцены и бандл ассета совпадают (Warning).
- Вызывать валидаторы для значений свойств на ключевых кадрах.
- Убеждаться, что ключевые кадры правильно отсортированы и не содержат повторов.
- Убеждаться, что нет таких двух маркеров, у которых кадр совпадает.
