# Валидация

Валидация позволяет контроллировать корректность данных в ассетах. В Цитрусе есть несколько способов вызова валидации и несколько способов связывания валидаторов с данными.

Способы вызова валидации.

1. Вызывать валидаторы можно с помощью Orange Action `Validate Assets`
2. Если в `.citproj` файле есть ключ `"ValidateOnCook": true` то во время кука ассетов валидация будет вызвана для каждого нового или изменённого ассета. В случае ошибок валидации кук ассетов прерывается.
3. В некоторых местах через интерфейс Танжерина. Например в инспекторе. Такая валидация неполная, вызывается не все валидаторы и не для всех объектов. Постепенно будет пополняться.

Способы задания валидаторов

1. Валидация по свойству
2. Валидация по типу
3. Валидация по расширению ассета

В любом из этих случев вам надо реализовать интерфейс `Lime.Validation.IValidator<T>` где T это входной тип данных для валидации. В нём надо реализовать единственный метод 

```csharp
IEnumerable<(Lime.Validation.Result Result, string Message)> Validate(T value);
```
При вызове этого метода будет использована не генерик версия данного интерфейса `Lime.Validation.IValidator`, это подразумевает проверку на совместимость типа значения с типом указаным в реализации валидатора и, в случае прохождения проверки, последующий каст `value` из `object` в `T`. 

Проверка реализуется через `IValidator.IsValueTypeCompatible`. Генерик версии интерфейса валидатора содержит реализую данной проверки по-умолчанию:

```C#
      bool IValidator.IsValueTypeCompatible(object value, Type valueType)
      {
        return value is T || typeof(T).IsAssignableFrom(valueType);
      }
```

которая позволяет проверять удовлетворительность типа, даже если `value == null`.

`Lime.Validation.Result` может быть `Info`, `Error` или `Warning`. В Message должен содержаться текст соответствующий результату. Этот метод должен перечислять пары результат и сообщение согласно логике валидатора. Примеры валидаторов можно посмотреть в Lime.Validation. 

Все валидаторы не должны иметь состояния, т.к. не гарантируется, будут ли они пересозданы или закешированы в той или иной ситуации.

Далее реализация этого интерфейса либо регистрируется в `Orange.ValidationRunner` либо является атрибутом проперти или класса.

## Валидация свойства

Валидаторы свойств извлекаются из атрибутов свойства с помощью рефлексии. То есть чтобы повесить валидатор на свойство надо унаследоваться от `System.Attribute` и реализовать `IValidator<T>`, а затем применить его к свойству.

Такие валидаторы можно параметризировать и в каждом конкретном случае передавать параметры применимые к конкретному свойству. Например см. `Lime.Validation.Range`.

Только для валидаторов свойств проводится проверка на реализацию интерфейса `Lime.Validation.IRequireOwner`, если она есть, то перед вызовом валидации валидатору будет назначен владелец. При этом проверяемое значение для свойства не обязательно должно быть уже присвоено, т.к. оно передаётся в `Validate` отдельно.

Только для валидаторов свойств проводится проверка не реализацию интерфейса `Lime.Validation.PassThroughEnumerable`, если она есть, то такие валидаторы будучи назначенными на свойства будут применяться не к самому свойству, а к его элементам, если свойство реализует `IEnumerable`. Это верно также для вложенных перечислений, например `public List<List<List<int>>> List { get; set; }`. Отстановка спуска по вложенности перечислений происходит в момент когда генерик атрибут очередноо `IEnumerable` проходит проверку `IValidator.IsValueTypeCompatible`

Валидаторы свойств вызываются для всех свойств маркированных `YuzuMember` через `Orange.ValidationRunner.ValidateObject` (который можно использовать в своих валидаторах ассетов, а также используется для валидации сцен), а также для `YuzuMember` и `TangerineInspect` маркированных полей валидаторы свойств будут вызваны в инспекторе в Танжерине. (И в некоторых других интерфейсах редактирования свойств в танжерине).

## Валидация типа

Аналогично валидации свойства, но атрибут применяется к объявлению типа.

Вызывается через　`Orange.ValidationRunner.ValidateObject` для всех значений.

Вызывается для всех значений свойств в Танжерине в инспекторе. Для поиска атрибутов валидации также перечисляются интерфейсы, которые реализует рантайм тип данного значения свойства.


## Валидация ассета

Такой валидатор должен валидировать значение типа `string`. Это путь к ассету в текущем бандле (входной бандл для кука, asset directory). Если данный ассет можно десериализовать в инстанс некого класса, то для из него можно вызвать `Orange.ValidationRunner.ValidateObject` и перечислить его результаты. 

При куке ассетов для каждого нового или изменённого файла в директории ассетов проекта, если данный файл попадает в один из cooking stages, вызываются все валидаторы зарегистрированные через Orange.ValidationRunner.RegisterAssetValidator.

Также через Orange Action -> Validate Everything валидаторы ассетов будут вызваны для каждого ассета в директории ассетов.

## Примеры того, что можно валидировать.

- Символы в путях и айди. Если у вас в проекте естьк акие-то соглашения по именованию, можно проверять эти соглашения.
- Для изображений можно проверять что они не сильно большие, если попробовать частично выяснить кладётся ли оно в атлас или нет, то в случае если нет, можно проверять, насколько оно не вписывается в степень двойки.
- Про размер изображений -- проверять размер на диске, то есть если по факту файл занимает в несколько раз больше чем разжатое изображение, возможно там какая-то метадата лишняя.
- Можно проверять, что цветовой профиль отсутсвует или указан СРГБ, который должен у нас использоваться согласно документации. Ну и что угодно в кастомных компонентах и виджетах.
- Убеждаться, что для текстуры виджета установленны параметры, которые требуются данному виджету. (Например WrapModeU/V == Clamp/Mirror)
- Проверять, что бандл сцены и бандл ассета совпадают (Warning).

## Примеры валидаторов

Большинство этих валидаторов "одноразовые" в том смысле, что их использование имеет смысл только внутри движка и они используются только в одном месте.

- `SizeInfoAttribute` предполагая наличие у типа свойства `Texture` сопоставляет значение `Vector2` поля на которое повешен и размер текстуры. При несовпадении выводит сообщение и результат типа `Info`.
- `RatioInfoAttribute` аналогично предыдущему, но следит за соотношением сторон.
- `RangeAttribute` диапазон допустимых значенй для свойства.
- `DefaultCharsetAttribute` содержание в строке недопустимых символов.
- `MatchRegexAttribute` соответствие строки на регулярному выражению
- `TileImageTextureAttribute` врап мод текстуры для TiledImage
- `NodeParentCompositionAttribute` допустимость данного типа родительской ноды для его дочерней ноды. Допустмые родители задаются через атрибут `TangerineAllowedParentTypes`
- `NodeChildrenCompositionAttribute` допустимость данного типа дочерней ноды для его родительской ноды. Допустмые типы дочерних нод задаются через атрибут `TangerineAllowedChildrenTypes`
- `NodeComponentOwnerCompositionAttribute` допустимость данного типа владельца для компонента. Допустимые владельцы задаются через атрибут `AllowedComponentOwnerTypes`.
- `ContentsPathAttribute` существование внешней сцены.
- `KeyframePropertyValuesAttribute` вызывает существующие валидаторы свойств, для каждого значения свойства на ключевых кадрах.
- `EnsureKeyframeListOrderAttribute` отсортированность списка ключевых кадров по номеру кадра.
- `EnsureOnlyOneAnimatorPerPropertyAttribute` наличие не более чем одного аниматора для свойства.
- `EnsureMarkerListOrderAttribute` отсортсированность маркеров в списке маркеров анимации по номеру кадра.
- `SerializableAssetExistsAttribute` существование сериализуемого ассета в текущем бандле. Расширения для сериализуемых ассетов указываются с помощью атрибута `SerializableAssetAttribute`. Класс сериализуемого ассета должен реализовывать интерфейс `ISerializableAsset`.
- `FilePathExistsAttribute` существование файла в текущем бандле.
